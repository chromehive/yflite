<?php

/**
 * YFlite Framework Bootstrap (Enhanced)
 * Added route exposure and offline behavior control
 */

// Load helpers
require_once __DIR__ . '/helper.php';
require_once __DIR__ . '/security.php';

// Load route definitions
$routes = require_once __DIR__ . '/route.php';

// Get request URI safely
if (!isset($_SERVER['REQUEST_URI'])) return;

$rawUri = $_SERVER['REQUEST_URI'] ?? '/';

$parsed = parse_url($rawUri, PHP_URL_PATH);

if ($parsed === false || $parsed === null) {
    header("Location: /");
    exit;
}

// Ensure $parsed is ALWAYS a string
if (!is_string($parsed)) {
    $parsed = '/';
}

// Normalize duplicate slashes anywhere (except http://)
$parsed = preg_replace('#/+#', '/', $parsed);

// SECURITY: Block directory traversal and hidden-dot attacks
if (preg_match('#(\.\./|\./|//\.|^\.{1,2}$)#', $parsed)) {
    http_response_code(400);
    exit('Invalid URI');
}

// SECURITY: block deeply suspicious sequences of dots
if (preg_match('#\.{3,}#', $parsed)) {
    http_response_code(400);
    exit('Invalid URI');
}

$uri = rtrim($parsed, '/');

if ($uri === '' || $uri === false) {
    $uri = '/';
}

$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';

// var_dump($uri, $method, $routes);
// exit(0);
// Optional: strip base path if app not in web root
// $base = str_replace('/public', '', dirname($_SERVER['SCRIPT_NAME']));
// $uri = '/' . trim(str_replace($base, '', $uri), '/');

// Alias map (extend in config/route_aliases.php if you want)
$default_aliases = [
    ':int'      => '(\d+)',
    ':id'       => '(\d+)',
    ':slug'     => '([a-zA-Z0-9-_]+)',
    ':username' => '([a-zA-Z0-9_]+)',
    ':uuid'     => '([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})',
    ':date'     => '([0-9]{4}-[0-9]{2}-[0-9]{2})',
    ':alpha'    => '([A-Za-z]+)',
    ':alphanum' => '([A-Za-z0-9]+)',
    ':any'      => '([^/]+)',
];

/**
 * Expand route aliases into regex groups and collect parameter names.
 *
 * @param string $pattern Route pattern from app/routes/index.php in base directory (may include :tokens)
 * @param array $aliases Alias map token => regex (optional)
 * @param array &$paramNames Output param names (ordered)
 * @return string Expanded pattern (regex-ready, without ^ $ anchors)
 */
function expand_route_aliases(string $pattern, array $aliases = null, array &$paramNames = []): string
{
    global $default_aliases;

    if ($aliases === null) $aliases = $default_aliases;

    // If config override file exists, merge it (optional)
    $customFile = __DIR__ . '/../configs/route_aliases.php';
    if (file_exists($customFile)) {
        $custom = include $customFile;
        if (is_array($custom)) $aliases = array_merge($aliases, $custom);
    }

    $paramNames = [];

    // Find tokens like :tokenName in the pattern
    // We allow tokens to contain letters, numbers, and underscores
    if (preg_match_all('/:([a-zA-Z0-9_]+)/', $pattern, $tokenMatches)) {
        $tokens = $tokenMatches[1]; // list of token names (without colon)
        foreach ($tokens as $token) {
            $aliasKey = ':' . $token;
            // Determine regex replacement: if alias exists, use it; otherwise fallback to generic segment
            $replacement = $aliases[$aliasKey] ?? '([^/]+)';
            // Replace only the first occurrence of the exact aliasKey to preserve other same-named parts order
            $pattern = preg_replace('/' . preg_quote($aliasKey, '/') . '/', $replacement, $pattern, 1);
            // Record param name for mapping later
            $paramNames[] = $token;
        }
    }

    return $pattern;
}

$matched = false;
$matches = [];

foreach ($routes as $route) {
    // Pattern: [METHOD, route, handler, middleware, exposed, offlineAccessible]
    [$allowedMethod, $pattern, $handler, $middlewares, $expose, $offline] =
        array_pad($route, 6, null);

    // Normalize defaults
    $middlewares = $middlewares ?: null;
    $expose = $expose ?? false;
    $offline = $offline ?? 'never';

    if ($method !== $allowedMethod) continue;

    // Determine whether the author wrote a raw regex (contains '(' ), or an alias-style route
    $isRegexRoute = strpos($pattern, '(') !== false && strpos($pattern, ':') === false;

    $paramNames = [];

    if ($isRegexRoute) {
        // Raw regex route â€” match exactly as before
        $regex = '#^' . $pattern . '$#';
    } else {
        // Expand aliases (e.g., :slug -> ([a-zA-Z0-9-_]+)) while collecting param names
        $expanded = expand_route_aliases($pattern, null, $paramNames);
        // Anchor and allow optional leading/trailing slashes behavior consistent with previous router
        $regex = '#^' . $expanded . '$#';
    }

    if (preg_match($regex, $uri, $pregMatches)) {
        // $pregMatches[0] is the full match; remove it to keep only capture groups
        array_shift($pregMatches);

        // Build both positional matches (same as before) and named param map
        $matches = $pregMatches; // numeric array for backward compatibility

        $route_params = [];
        // Map capture groups to names if available
        if (!empty($paramNames)) {
            foreach ($paramNames as $i => $pname) {
                if (isset($matches[$i])) {
                    $route_params[$pname] = $matches[$i];
                } else {
                    $route_params[$pname] = null;
                }
            }
        }
        // Expose named params globally for controller convenience
        $GLOBALS['route_params'] = $route_params;

        // Optional middleware handling
        if ($middlewares) {
            $middlewareList = array_map('trim', explode(',', $middlewares));
            foreach ($middlewareList as $middleware) {
                [$mwFile, $mwFunc] = explode(':', $middleware);
                require_once __DIR__ . "/../middlewares/$mwFile.php";
                $result = call_user_func($mwFunc);
                if ($result === false) {
                    $matched = true;
                    break 2;
                }
            }
        }

        // Handle route exposure (can be used later by yf attributes)
        if ($expose) {
            header('X-YFlite-Expose: true');
        }

        // Handle offline caching signals (used by yf/alpine offline store)
        header("X-YFlite-Offline: $offline");

        // Run controller
        // [$file, $func] = explode(':', $handler);
        [$file, $func] = array_pad(explode(':', $handler), 2, null);
        require_once __DIR__ . "/../controllers/$file.php";

        $result = call_user_func_array($func, $matches);
        if ($result !== null) echo $result;

        $matched = true;
        break;
    }
}

if (!$matched) {
    http_response_code(404);
    $GLOBALS['route_params'] = [];
    render('404', ['pageTitle' => '404 Not Found']);
}
